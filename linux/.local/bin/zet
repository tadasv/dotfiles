#!/usr/bin/bash
# shellcheck disable=SC2016,SC2119
set -e

(( BASH_VERSINFO[0] < 4 )) && echo "Bash 4+ required." && exit 1

EXE="${0##*/}"

declare -A help # associative arrays *require* declaration

: "${PAGER:=more}"
: "${EDITOR:=vi}"
: "${HELP_BROWSER:=}"
: "${GITUSER:=$USER}"
: "${GITBRANCH:=main}"
: "${ZETDIR:=$GHREPOS/zet}"
: "${ZET_CAST_DIR:=$HOME/Videos/ZettelCasts}"
: "${ZET_CAST_FOOTER:=}"
: "${ZET_CAST_CATEGORY:=28}" # Science and Techology

EXE=${0##*/}

# ------------------------- utility functions ------------------------

_newest() {
  IFS=$'\n'
  local -a f=($(ls -1 --color=never -trd ${1:-.}/* 2>/dev/null))
  [[ ${#f} > 0 ]] && echo "${f[-1]}"
}

# ----------------------------- commands -----------------------------

help[main]='
# Zettelkasten Utility with Live Casting

The `zet` command is a bash script for creating, querying, and managing
a single [Zettelkasten] GitHub repo.

[Zettelkasten]: <https://github.com/rwxrob/zet/search?q=Zettelkasten

## Usage

```

## Dependencies

The `zet` script requires Bash 4.0 (or above) and depends on the
following commands not normally installed by default:

* `yt`
* `pandoc`
* `curl`
* `jq`
* `auth`

## Environment

* `EDITOR`
* `GITUSER`
* `HELP_BROWSER`
* `KN`
* `ZETDIR`

## Completion

Add the following to bashrc to enable completion (replacing zet with
your multicall executable name):

    complete -C zet zet

Note that you will need one such complete line for every multicall
variation of this script:

    ln -s zet log
    complete -C log log

## Filter Commands

True to the UNIX philosophy, most all commands can either take an
argument or will read from standard input recursively calling the same
command once for each line of input allowing commands to be called from
within Ed/Vim sessions as well as from the command line in pipeline
form.

## Path to Zettelkasten Directory

Checks for `$ZETDIR` or `$KN` variables (in that order). If found, use
those variables for the parent directory. If they do not exist, check
for the existance of the default directory and create the folder if
necessary. This not only allows for customization of the parent
directory via `$ZETDIR`, but also allows for compatibility with the
KEG/KN toolset. This directory is expected to contain one or more
subdirectories, each of which is usually a git repository that directly
matches the name of the multicall executable (ex: `$ZETDIR/zet`).

## Legal

Copyright 2021 Rob Muhlestein <rob@rwx.gg>  
Released under Apache-2.0 license  
Please mention https://youtube.com/rwxrob'

help[cast]='

### The `cast zet` Command

The `zet` command looks within the description for a `[ZETID:<id>]` tag
(usually near the bottom of the description). This tag allows videos to
be re-associated with a different zettel after having already been
uploaded. If none is found, it attempts to extract a zettel id from the
file name from the `fileDetails` and if it appears to be a zettel
identifier returns it (required for new uploads).'

command_cast() {
  ! _have yt && echo "<cast requires yt be available>" && return 1
  case "$1" in
    start) shift; command__cast_start "$@"; return $?;;
    last) shift; command__cast_last "$@"; return $?;;
    pending) shift; command__cast_pending "$@"; return $?;;
    zet) shift; command__cast_zet "$@"; return $?;;
    sync) shift; command__cast_sync "$@"; return $?;;
    uploads) shift; command__cast_uploads "$@"; return $?;;
    open) shift; yt open "$1"; return $?;;
  esac
}

command__cast_start() {
  local topic
  if _have iam; then
    topic="$(topic)"
    iam recording "$*"
  fi
  _have pomo && pomo duration 10m
  local zetid=$(command_isosec)
  mkdir "/tmp/$zetid"
  echo -e "# $*\n\n*remember to turn off music, start recording*\n\n1. Scenario\n2. Solution\n3. Steps\n4. Summary\n" > "/tmp/$zetid/README.md"
  local zetid
  zetid=$(command_import "/tmp/$zetid")
  (( $? == 0 )) && rm -rf "$zetid"
  command_edit "$zetid"
  if [[ -n "$topic" ]]; then
    t "$topic"
  fi
  _have pomo && pomo stop
  command__cast_pending_prep
}

command__cast_last() {
  _newest "$ZETCASTDIR/Pending"
}

command__cast_pending() {
  case $1 in
    ids) shift; command__cast_pending_ids "$@"; return $?;;
    prep) shift; command__cast_pending_prep "$@"; return $?;;
    dir) shift; command__cast_pending_dir "$@"; return $?;;
    post) shift; command__cast_pending_post "$@"; return $?;;
    archive) shift; command__cast_pending_archive "$@"; return $?;;
    publish) shift; command__cast_pending_publish "$@"; return $?;;
    paths) shift; command__cast_pending_paths "$@"; return $?;;
  esac
  command__cast_pending_paths "$@"
}

command__cast_pending_paths() {
	find "$ZETCASTDIR/Pending" -type f | sort
}

command__cast_pending_prep() {
	for i in $(command__cast_pending); do
    if [[ $i =~ [0-9]{14,}.mkv ]]; then
      echo Skipping $i
      continue
    fi
    local zetid
    zetid=$(command_for "$i")
    echo "$i -> $zetid.mkv" 
		mv "$i" "$ZETCASTDIR/Pending/$zetid.mkv"
	done
}

command__cast_pending_dir() {
  echo "$ZETCASTDIR/Pending"
}

command__cast_uploads() {
  case $1 in
    sync) shift; command__cast_uploads_sync "$@"; return $?;;
  esac
  while IFS= read -r line;do
    local ytid=${line%% *}
    local title=${line#* }
    [[ $title =~ ^[0-9]{14,}$ ]] || continue
    echo "$ytid"
  done < <(yt uploads 50)
}

command__cast_uploads_sync() {
  while IFS= read -r ytid;do
    command__cast_sync "$ytid"
  done < <(command__cast_uploads)
}

command__cast_pending_ids() {
  while IFS= read -r path;do
    local id=${path##*/}
    echo ${id%%.*}
  done < <(command__cast_pending)
}

command__cast_pending_post() {
  while IFS= read -r id;do
    read -u 2 -p "Tags for '$(command_title "$id")'? " -a tags
    command_post "$id" "${tags[@]}"
  done < <(command__cast_pending_ids)
}

command__cast_pending_archive() {
  while IFS= read -r path;do
    echo "$path -> $ZETCASTDIR"
    mv "$path" "$ZETCASTDIR"
  done < <(command__cast_pending)
}

command__cast_pending_publish() {
  read -p 'Everything uploaded to YouTube from Pending? ' resp
  [[ $resp =~ ^[yY] ]] || return 1
  command__cast_uploads_sync
  command__cast_pending_post
  command__cast_pending_archive
  echo "Don't forget to activate monetization from YouTube GUI."
}

command_post() {
  _filter "$@" && return $?
  ! _have post && echo '<post command not found>' && return 1
  local zetid="$1"
  [[ $zetid = last ]] && zetid=$(command_last)
  [[ -z "$zetid" ]] && echo '<zetid required>' && return 1
  local title video tags buf
  title=$(command_title "$zetid") || (echo '<title empty>' && return 1)
  video=$(command_video "$zetid") || true
  [[ ${video:0:1} = '<' ]] && video=''
  zeturl=$(command_url "$zetid")
  shift;
  tags=($(command_tag "$zetid") $@)
  tags="${tags[@]/#/\#}"
  if [[ -n "$video" ]];then
    buf+="📺 "
  else
    buf+="📜 "
  fi
  local n=$'\n'
  buf+="$title$n$n"
  if [[ -n "$video" ]];then
    buf+="$video$n$n"
  else
    buf+="$zeturl$n$n"
  fi
  [[ -n "$tags" ]] && buf+="$tags$n"
  printf "%s\n" "$buf"
  post "$buf"
}

command__cast_zet() {
  _filter "$@" && return $?;
  local video=$(yt video "$1")
  local name=$(jq -r ".fileDetails.fileName" <<< "$video")
  local desc=$(jq -r ".snippet.description" <<< "$video")
  if [[ $desc =~ \[ZETID:([0-9]{14,})\] ]]; then
    echo "${BASH_REMATCH[1]}"
    return 0
  fi
  if [[ $name =~ ^([0-9]{14,})\.mkv ]]; then
    echo "${BASH_REMATCH[1]}"
    return 0
  fi
}

command__cast_sync() {
  local id zetid ytid
  if [[ $1 = last ]]; then
    id=$(command_last)
  else
    id="${1##*/}"
  fi
  if [[ $id =~ ^[0-9]{14,}$ ]]; then
    zetid="$id"
    ytid=$(command_video "$zetid") || true
    ytid=${ytid##*/}
  else
    ytid="$id"
    ytid=${ytid##*/}
    zetid=$(command__cast_zet "$ytid")
  fi
  local n=$'\n' foot desc
  [[ -z "$ytid" ]] && echo '<failed to lookup ytid>' && return 1
  [[ -z "$zetid" ]] && echo '<failed to lookup zetid>' && return 1
  local title=$(command_title "$zetid")
  local body=$(command_body "$zetid" codeless)
  local zeturl="https://github.com/$GITUSER/zet/tree/$GITBRANCH/$zetid"
  [[ -n "$ZETCASTFOOT" ]] && foot=$(command_body "$ZET_CAST_FOOTER")
  desc="$body$n$n$foot$n$n[ZETID:$zetid]$n$zeturl"
  yt publish "$ytid" "$title" "$desc" "$ZET_CAST_CATEGORY"
  command_video "$zetid" "$ytid" > /dev/null
  echo "👍 synced $zetid -> https://youtu.be/$ytid"
}

help[import]='
The `import` command copies an exactly duplicate of the directory passed
as the first argument. The first argument is assumed to be a unique
zettel identifier (isosec). (Note that in the extemely unlikely event
that an identifier conflicts, the import will fail.) '

command_import() {
    _filter "$@" && return $?
    local dir="$(command_dir)"
    [[ ! -d "$1" ]] && return 1
    mv "$1" "$dir"
    command_commit "${1##*/}" &>/dev/null
    echo "${1##*/}"
}

help[delete]='
The `delete` command removes the indicated zettel directory from the zet
repo and directory, and commits and pushes the removal. The word "last"
can be used instead of a zettel identifier for convenience.'

command_delete() {
    _filter "$@" && return $?
    local dir="$(command_dir)"
    local zetid="$1"
    [[ $zetid = last ]] && zetid=$(command_last)
    if [[ ! -d "$dir/$zetid" ]]; then
        echo "Does not exist '$zetid'"
        return 1
    fi
    rm -rf "$dir/$zetid"
    echo "Removed $dir/$zetid"
    cd "$dir" &>/dev/null
    git add -A "$dir/$zetid" &>/dev/null
    git commit -m "Deleted $zetid" &>/dev/null || true
    git push &>/dev/null
    cd - &>/dev/null
}

command_grep() { command_titles | grep -iP "$1"; }

command_chat() {
  _filter "$@" && return $?
  _have chat || return 1
  chat <<< $(command_url "$1")
}

command_url() {
  _filter "$@" && return $?
  local zetid="$1"
  [[ -z "$zetid" || $zetid = last ]] && zetid=$(command_last)
  echo "https://github.com/$GITUSER/zet/tree/$GITBRANCH/$zetid"
}

command_open() { 
  ! _have open && echo '<open not found>' && return 1
  open $(command_url "$@")
}

command_commit() {
  _filter "$@" && return $?

  # if no zet, bail
  local dir
  dir="$(command_dir)/$1"
  local readme="$dir/README.md"
  [[ ! -r $readme ]] && echo "<not found: $1>" && return 1

  # git commit keeping title as commit message 
  local title
  title=$(command_title "$1")
  cd "$dir"
  git add -A "$dir"
  git commit -m "$title"
  git push
  cd -

}

command_video() {
  _filter "$@" && return $?

  # accept zet or yt ids  
  local zetid ytid changed
  if [[ $1 =~ ^[0-9]{14,}$ ]]; then
    zetid="$1"
    ytid="${2##*/}"
  elif [[ $1 = last ]]; then
    zetid=$(command_last)
    ytid="${2##*/}"
  else
    ytid="${1##*/}"
    zetid=$(zet cast zet "$1")
  fi

  # if no zet, bail
  local dir readme
  dir="$(command_dir)/$zetid"
  readme="$dir/README.md"
  [[ ! -r "$readme" ]] && echo "<not found: $zetid/$ytid>" && return 1

  # if zet has vid line...
  if [[ $(sed '3q;d' "$readme") =~ ^📺\ \<https://youtu.be/(.*)\> ]]; then

    # update if ytid 
    if [[ -n "$ytid" ]]; then
      # FIXME following needs to be non-provider specific
      echo -e "3c\n📺 <https://youtu.be/$ytid>\n.\nwq" | ed "$readme" >/dev/null
      changed=1

    # read it to print later
    else
      ytid=${BASH_REMATCH[1]}
    fi

  # zet does not have vid line
  else

    # so add it if have video id
    if [[ -n "$ytid" ]]; then
      echo -e "2a\n📺 <https://youtu.be/$ytid>\n\n.\nwq" | ed "$readme" >/dev/null
      changed=1
    fi
  fi

  # always print the url to the video id
  if [[ -n "$ytid" ]]; then
    echo "https://youtu.be/$ytid"
    [[ $changed = 1 ]] && command_commit "$zetid"
  else
    echo "<no video found in $zetid>"
    return 1
  fi
}

command_urlencode() {
  _filter "$@" && return $?
  local string="$*"
  local strlen=${#string}
  local encoded=""
  local pos c o
  for ((pos = 0; pos < strlen; pos++)); do
    c=${string:$pos:1}
    case "$c" in
    [-_.~a-zA-Z0-9]) o="${c}" ;;
    *) printf -v o '%%%02x' "'$c'" ;;
    esac
    encoded+="${o}"
  done
  echo "${encoded}"
}

command_isosec() { date -u +%Y%m%d%H%M%S "$@"; }
command_isonan() { date -u +%Y%m%d%H%M%S%N "$@"; }

command_dir() {
  local id="$1"
  [[ $id = last ]] && id=$(command_last)
  local dir="$ZETDIR"
  [[ -n "$id" ]] && dir="$ZETDIR/$id"
  [[ -d "$dir" ]] && echo "$dir"
}

help[create]='
The `create` command creates a Zettel directory with an isosec unique
name within the `$ZETDIR` parent directory.  It then opens the `$EDITOR`
(if set) or `vim`. After the edits are complete prompts to commits the
repo with `git commit` using the first 50 characters of the first line
as the commit message (ignoring heading hashtags if prefixed) and
pushes.'

command_create() {
  local title="$*"
  local dir readme
  dir="$(command_dir)/$(command_isosec)"
  readme="$dir/README.md"
  mkdir -p "$dir"
  printf "# %s\n\n" "$title" > "$readme"
  "${EDITOR:-vim}" "$readme"
  cd "$dir" &>/dev/null
  [[ -s "$dir/README.md" ]] || return 1
  line=$(head -1 "$dir/README.md" | sed 's/#\+ *//')
  test -n "$line"
  echo "Committing: $line"
  git add -A "$dir" &>/dev/null
  git commit -m "$line" &>/dev/null
  git push &>/dev/null
}

command_edit() {
  local dir zetid
  if [[ $1 =~ ^[0-9]{14,}$ ]]; then
    zetid="$1"
    dir="$(command_dir)/$1"
  elif [[ $1 = last ]]; then
      zetid="$(command_last)"
    dir="$(command_dir)/$zetid"
  else
    zetid=$(yt zet "$1")
    if [[ -z "$zetid" ]]; then
      echo "Unable to determine zet id for $1"
      return 1
    fi
    dir="$(command_dir)/$zetid"
  fi
  local readme="$dir/README.md"
  [[ ! -r "$readme" ]] && echo "Not found." && return 1
  "${EDITOR:-vim}" "$readme"
  read -r -p "Commit? " resp
  [[ $resp =~ ^[yY] ]] && command_commit "$zetid"
}

command_dex() {
  case $1 in 
    titles) shift;command__dex_titles "$@"; return $?;;
    tags) shift;command__dex_tags "$@"; return $?;;
  esac
}

command_titles() { command__dex_titles; }

command__dex_titles() {
  local dir title
  dir=$(command_dir)
  while IFS= read -u 7 -r d; do
    local id=${d##*/}
    [[ -r "$d/README.md" ]] || continue
    IFS= read -r title < "$d/README.md"
    [[ $title =~ ^#\  ]] || title="<untitled>"
    title="${title#*# }"
    echo "$id $title"
  done 7< <(find "$dir" -maxdepth 2 -type d -path '*/2*'|sort)
}

help[changes]='
Outputs two columns of data: the second a zettel was changed, and the
zettel ID. Because both of these can be read directly from the inode for
the `$ZETDIR` directory the output is instantaneous. Because titles
change and parsing them out adds unnecessary delay, this file will never
included titles (use `titles` or `title` instead for that).  '

command_changes() {
  mapfile -t < <(
    TZ=Z \
    find "$ZETDIR" \
    -maxdepth 2 \
    -type d \
    -path '*/2*' \
    -printf "%CY%Cm%Cd%CH%CM%CS %f\n" \
    | sort -rn
  )
  for i in "${MAPFILE[@]}"; do
    echo "${i%%.*} ${i##* }"
  done
}

command__mark_link() {
  _filter "$@" && return $?;
  local id="${1%% *}"
  #TODO have it see $* as well
  local title="${1#* }"
  [[ -z "$title" ]] && title=$(command_title "$1")
  echo "* [$id](/$id/) $title"
}

command__mark_url() {
  _filter "$@" && return $?;
  local id="${1%% *}"
  #TODO have it see $* as well
  local title="${1#* }"
  [[ -z "$title" ]] && title=$(command_title "$1")
  echo "* [$id]($(command_url "$id")) $title"
}

command_mark() {
  case $1 in 
    url) shift;command__mark_url "$@"; return $?;;
    link) shift;command__mark_link "$@"; return $?;;
  esac
}

command_last() {
  mapfile titles < <(command_titles)
  local last=${#titles[@]}
  echo "${titles[$last-1]%% *}"
}

command_text() {
  _filter "$@" && return $?
  local dir readme
  dir="$(command_dir)/$1"
  readme="$dir/README.md"
  [[ -r "$readme" ]] || return 1
  local buf
  if [[ $2 = codeless ]];then
    buf=$(command_codeless "$1")
  else
    buf=$(<"$readme")
  fi
  command -v pandoc &>/dev/null \
    || (echo "'$EXE text' requires pandoc" && return 1)
  pandoc -f gfm -t plain --wrap=none <<< "$buf"
}

command_source() {
  _filter "$@" && return $?
  local dir readme
  dir="$(command_dir)/$1"
  readme="$dir/README.md"
  [[ -r "$readme" ]] || return 1
  echo "$(<"$readme")"
}

command_title() {
  _filter "$@" && return $?
  local id="$1"
  [[ $id = last ]] && id=$(command_last)
  local dir readme title
  dir="$(command_dir)/$id"
  [[ -d $dir ]] || return 1
  readme="$dir/README.md"
  read -r title < "$readme"
  [[ ! $title =~ ^#\  ]] && return 1
  pandoc -f gfm -t plain --wrap=none <<< "${title#\# }"
}

command_tags() { command__dex_tags; }

command__dex_tags() {
  local buf tags n=$'\n'
  mapfile -t ids < <(command_ids)
  for i in "${ids[@]}";do
    mapfile -t tags < <(command_tag "$i")
    (( ${#tags[@]} > 0 )) || continue
    buf+="$i ${tags[*]}$n"
  done
  echo -n "$buf"
}

command_tag() {
  _filter "$@" && return $?
  local id="$1"
  [[ $id = last ]] && id=$(command_last)
  local dir readme tags
  dir="$(command_dir)/$id"
  [[ -d $dir ]] || return 1
  readme="$dir/README.md"
  [[ -r $readme ]] || return 1
  #TODO if more than first argument assume want to set
  tag=$(tail -1 "$readme")
  [[ $tag =~ ^\ {4,}(#.+) ]] || return 0
  echo "${BASH_REMATCH[1]//#/}"
}

command_daemon() {
  while true; do
    sleep
  done
}

command_body() {
  _filter "$@" && return $?
  local dir readme title buf eol
  dir="$(command_dir)/$1"
  [[ -d $dir ]] || return 1
  readme="$dir/README.md"
  if [[ $2 = codeless ]];then
    buf=$(command_codeless "$1")
  else
    buf=$(<"$readme")
  fi
  eol=$'\n'
  [[ $buf =~ ^\#\  ]] && buf=${buf#*$eol$eol} 
  buf=${buf#📺 *$eol$eol}
  pandoc -f gfm -t plain --wrap=none <<< "$buf"
}

command_query() {
  _filter "$@" && return $?
  [[ -z "$1" ]] && echo "Missing search query." && return 1
  term="$*"
  it="https://github.com/$GITUSER/$EXE/search?q=$(command_urlencode "$term")"
  echo "[$term]: <$it>"
  command -v chat &>/dev/null && chat "$it"
}

command_ids() {
  while read -r line; do
    echo "${line##*/}"
  done < <(find "$(command_dir)" -maxdepth 2 -type d -path '*/2*'| sort)
}

help[before]='
The `before` command prints the zet id of the first zettel immediately
preceeding the one passed as an argument. This command can be called as
a filter.'

command_before() {
  _filter "$@" && return $?
  local prev
  while read -r cur; do
    (( cur > id )) && break
    prev=$cur
  done < <(command_ids)
  echo "$prev"
}

help[for]='
The `for` command attempts to detemine the zettel ID associated with the first argument, which can be many things:

* OBS recording file or path ending in `.mkv`
* YouTube URL

'

command_for() {
  _filter "$@" && return $?
  local mkv id
  mkv="$1"
  [[ $mkv == last ]] && mkv=$(mkvlast)
  [[ $mkv =~ - ]] && mkv=$(mkv2isosec "$mkv")
  id=${mkv##*/}
  id=${id%.mkv}
  command_before "$id"
}

help[after]='
The `after` command prints the zet id of the first zettel immediately
following the one passed as an argument. This command may be called as
a filter.'

command_after() {
  _filter "$@" && return $?
  local id="$1"
  while read -r cur; do
    (( cur > id )) && break
  done < <(command_ids)
  echo "$cur"
}

help[id]='
The `id` command prints the isosec identifier derived from the passed
argument:

1. If already an isosec and zet exists, print argument
2. If `last`, delegate to `zet last`
3. If isosec match found (`2[0-9]{13,}`), print match
4. If YouTube id or URL, delegate to `yt zet`

This command may be called as a filter.
'

command_id() {
    _filter "$@" && return $?
    echo would id
}


command_codeless() {
  _filter "$@" && return $?
  local incode=no
  while IFS= read -r line; do
    if [[ ${line:0:3} = '```' ]]; then
      if [[ $incode = yes ]]; then
        incode=no
        continue
      else
        incode=yes
        echo "[code snipped]"
        continue
      fi
    fi
    [[ $incode = yes ]] && continue
    echo "$line"
  done < <(command_source "$@")
}

# ------------------ builtin commands and functions ------------------
#          (https://github.com/rwxrob/template-bash-command)

help[usage]='Displays a summary of usage.'

command_usage() {
  local -a cmds
  for c in "${COMMANDS[@]}"; do
    [[ ${c:0:1} =~ _ ]] && continue
    cmds+=("$c")
  done
  local IFS='|'
  printf "usage: %s (%s)\n" "$EXE" "${cmds[*]}"
}

help[help]='
# Display Help Information

```
help [<command>]
```

Displays specific help information. If no argument is passed displays
general help information (main). Otherwise, the documentation for the
specific argument keyword is displayed, which usually corresponds to
a command name (but not necessarily). All documentation is written in
GitHub Flavored Markdown and will displayed as a web page if `pandoc`
and `$HELP_BROWSER` are detected, otherwise, just the Markdown is sent
to `$PAGER` (default: more).

Also see `readme` and `usage` commands.
'

command_help() { 
  local name="${1:-main}" title body
  title=$(_help_title "$name") || true
  if [[ -z "$title" ]]; then
    body="${help[$name]}"
    title="$EXE $name"
    [[ $name = main ]] && title="$EXE"
  else
    body="${help[$name]}"
    local eol=$'\n'
    body=${body#*$title}
  fi
  local file="/tmp/help-$EXE-$name.html"
  if _have pandoc ; then
    if _have "$HELP_BROWSER" && [[ -t 1 ]] ;then
      pandoc -f gfm -s --metadata title="$title" \
        -o "$file" <<< "$body"
      [[ -z "$2" ]] && cd /tmp && exec "$HELP_BROWSER" "$file"
      return 0
    fi
    pandoc -f gfm -s --metadata title="$title" \
      -t plain <<< "$body" | "$PAGER"
    return 0
  fi
  echo -e "$title\n\n$body" | "$PAGER"
}

help[readme]='
# Generate `README.md` File

```
command readme > README.md
```

The `readme` command will output the embedded help documentation in raw
GitHub Flavored Markdown suitable for use as a `README.md` file on
GitHub or similar hosting service.  '

command_readme() {
  _trim "${help[main]}"
  printf "\n## Commands\n\n"
  while IFS= read -r name; do
    local body
    [[ $name = main ]] && continue
    body=$(_trim "${help[$name]}")
    [[ $body =~ ^\# ]] || body="# The \`$name\` Command\n\n$body"
    printf "##%s\n\n" "$body"
  done < <(printf "%s\n" "${!help[@]}" | LC_COLLATE=C sort)
  echo -e "----\n\n*Autogenerated $(date)*\n"
}

_help_title() {
  _filter "$@" && return $?;
  local name="$1"
  while IFS= read -r line; do
    [[ $line =~ ^[:space]*$ ]] && continue
    [[ $line =~ ^#\ (.+) ]] && echo "${BASH_REMATCH[1]}" && return 0
    return 1
  done <<< "${help[$name]}"
}

_trim() {
  local it="${1#"${1%%[![:space:]]*}"}"
  echo -e "${it%"${it##*[![:space:]]}"}"
}

_have(){ type "$1" &>/dev/null; }

_jsonstr() {
  _buffer "$@" && return $?
  jq -MRsc <<< "$1"
}

_filter(){
  [[ -n "$1" ]] && return 1
  while IFS= read -ra args; do
    "${FUNCNAME[1]}" "${args[@]}"
  done
}

_buffer() {
  [[ -n "$1" ]] && return 1
  "${FUNCNAME[1]}" "$(</dev/stdin)"
}

# --------------------- completion and delegation --------------------
#         (better than . <(foo bloated_completion) in .bashrc)

while IFS= read -r line; do
  [[ $line =~ ^declare\ -f\ command_ ]] || continue
  COMMANDS+=( "${line##declare -f command_}" )
done < <(declare -F)
mapfile -t COMMANDS < <(LC_COLLATE=C sort < <(printf "%s\n" "${COMMANDS[@]}"))

if [[ -n $COMP_LINE ]]; then
  line=${COMP_LINE#* }
  for c in "${COMMANDS[@]}"; do
    [[ ${c:0:${#line}} == "${line,,}" && ${c:0:1} != _ ]] && echo "$c"
  done
  exit
fi

for c in "${COMMANDS[@]}"; do
  if [[ $c == "$EXE" ]]; then
    "command_$EXE" "$@"
    exit $?
  fi
done

if [[ -n "$1" ]]; then
  declare cmd="$1"; shift
  for c in "${COMMANDS[@]}"; do
    if [[ $c == "$cmd" ]]; then
      "command_$cmd" "$@"
      exit $?
    fi
  done
fi

command_usage "$@"
